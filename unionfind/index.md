# 算法笔记(1)：并查集


## 前言
我其实挺喜欢玩解密类的游戏，最早接触的这类游戏应该是诺基亚上的蒙娜丽莎拼图，那个时候总是瞎玩，有时三俩下就拼好，有时10分钟也不见得能成功。

其实当时**隐隐约约能感觉到有一种规律**，比如我总是先把当前能对上号的图片放到正确的位置，再观察余下的要怎么拼；比如有时为了挪动一块拼图到正确的位置而不得不挪动许多块，而这经常是结尾要做的事，将最后一块拼图挪进去，需要以一种“**奇怪**”的方法，我称之为**倒车入库**，那时在这种情况下总是有一种**奇妙**的感觉。可惜自己也并非聪慧过人 or 好奇心爆棚，所以也不曾探索他的规律。而现在，这叫做<mark>**算法**</mark>。

除了拼图之外，大概就是走迷宫了。经常会在报纸或者杂志书上面有一些迷宫，我就用着铅笔“暴力”尝试(~~哈哈其实有眼睛的参与，没有穷举那么暴力~~)。

所以在学习并查集的时候，我很**自然**的就想到了迷宫的例子。迷宫可以看作这样一个问题：是否存在一条从起点到终点的路径？若是，则给出这条路径；若否，请给出理由。


{{< admonition type=warning title="Warning" open=true >}}
实际上通过并查集我们并不知道这条连通路径具体是怎样的，我们要回答的首先是是否存在这样一条连通路径。
{{< /admonition >}}

## 问题

对于一个给定的迷宫，判断该迷宫是否有出口。

{{< image src="/images/maze.png" caption="迷宫"  >}}
对于这样较小的迷宫，肉眼就能很快得出答案，但对于大型迷宫来讲，就不得不借助计算机的帮助。然而迷宫问题对计算机来说相当困难，因为他并不像人一样能"**看见**"。


---

## 建模

因此我们需要继续简化问题。**要时刻记住，算法和编程是两个"领域"，编程是将算法处理成计算机能理解的形式，而算法是给出解决问题的步骤，算法才是最基本的。**

我们需要表示迷宫的每个"格子"，我们将每个格子**抽象**为一个对象，并用1～n的数字作为唯一标识。
{{< image src="/images/image-20241111153034790.png" caption="迷宫数字化">}}


{{< image src="/images/image-20241110215358585.png" caption="迷宫数字化的链接" >}}

接着考虑一个更简单的例子：

{{< image src="/images/image-20241110214512051.png" caption="一个更简单的例子" >}}


这个例子和迷宫的**区别**在于迷宫只有上下左右四个方向进行连接，而该例**任意两个元素之间都可以连接**。所以如果找到这个问题的算法，我们就能直接应用到迷宫上。这是第二层**抽象**。

现在，我们就将迷宫这个较**特殊**的问题**转化成**如下的<mark>**一般性**</mark>问题：  
{{< admonition type=quote title="问题的精确定义" open=true >}}
*问题：给出一组输入，判断任意两个元素之间是否相连。  
输入：第一行为正整数n，表示有多少个元素。余下每行表示这两个元素相连。  
输出：若相连，输出True;否则输出False。*
{{< /admonition >}}

此外，我们假设”相连“是一种等价关系，即具有如下性质:
{{< admonition type=note title="等价关系" open=true >}}
-   自反性：p和p是相连的。
-   对称性：如果p和q是相连的，那么q和p也是相连的。
-   传递性：如果p和q是相连的且q和r是相连的，那么p和r也是相连的。
{{< /admonition >}}

等价关系能够将对象分为多个**等价类**。对于该问题，当且仅当两个对象相连时它们才属于同一个等价类。至此我们将问题<mark>**转化**</mark>为求解连通分量。这是第三层抽象。至此，我们才正式开始算法的设计，前面都是具体的定义问题。

我们需要设计一种数据结构和算法，来<mark>**保存**</mark>已知的所有等价类的<mark>**足够多的信息**</mark>，并用它们来<mark>**判断**</mark>一对新对象是否是相连的(方法为判断它们是否属于同一个等价类)。这也叫动态连通性问题。

特别地，我们将等价类称为**连通分量**。

---

## 数据结构与API
{{< admonition type=important title="核心思想" open=true >}}
- 每个连通分量都有一个**唯一**标识符  
- 使用唯一标识符来判断两个对象是否属于同一个连通分量  
- 设计的数据结构应同时保存对象与其连通分量标识符的信息
{{< /admonition >}}

对于求解连通分量问题，我们可以**进一步细化**为如下算法雏形：

1.   一开始每个对象都是一个连通分量，所以我们有N个分量，并且我们需要为这N个分量设立唯一标识符。
2.   当给出一组连接时，我们需要**判断**它们是否属于同一个分量。
     -   若是，则无需操作。
     -   若不是，则**归并**这两个分量。
3.   我们需要查找给定对象所处的分量的标识符。
{{< admonition type=question title="为什么需要这个函数？" open=false >}}
- 我们假设两个对象`p,q`，他们的分量标识符为`m,n`。因为2中的归并操作会将`m, n`归并为一个代表分量的唯一标识符，我们现在并不知道是如何修改的。也许是把`m`变成`n`、把`n`变成`m`、或者新增一个唯一标识符`t`,将`m,n`都修改为`t`等等情况.......但我们知道的是这会修改`p,q`中**至少一个**对象的标识符。  
- 查找的难易程度会**取决于**算法的设计，我们只是像往常一样，将这种独立的操作封装为一个函数。因为这就是**函数设计的原则**。
{{< /admonition >}}
4.   通过上述两个函数，我们现在就可以查找两个对象是否属于同一分量，并返回结果。

因此我们给出如下API：

```python
class UF:
    def __init__(self, N):				 # 以整数标识(0～N-1)初始化N个对象
    def union(self， p, q):			   # 在p和q之间添加一条连接
    def find(self, p):				   # 查找给定对象所处的连通分量的标识符
    def connected(self, p, q):		   # 判断p和q之间是否存在连接
    def count(self):				   # 连通分量的数量
```

我们设计的<mark>**数据结构**</mark>如下：

-   使用数组的下标`i`表示`对象`。
-   数组的值`id[i]`来表示该对象的分量所对应的`标识符`。

对于`init`，我们使用每个对象`i`来初始化它的分量标识符，即`id[i] = i` (i属于0,N-1)

`union,find`是我们需要继续细化的算法

`connected`可以很方便地用`find(p) == find(q)`来判断。



因此我们定义出以下基类UF：

```python
class UF:
    
    def __init__(self, N):
      self.lens = N
      self.id = []
      for i in range(0, N):
        self.id.append(i)

    def union(self, p, q):
        return None
    
    def find(self, p): # 查找给定元素所处的集合的标识符
        return None

    def connected(self, p, q):
        return self.find(p) == self.find(q)
    
```

此外，为了分析算法的性能，我们将时间复杂度分析的<mark>**成本**</mark>定义为不同算法<mark>**访问数组的总次数**</mark>。
{{< admonition type=warning title="警惕时间复杂度陷阱" open=true >}}
时间复杂度分析不是真正的运行时间，不然得出的时间复杂度图像不稳定
{{< /admonition >}}

---

## 算法
{{< admonition type=tip title="" open=true >}}
`union()`与`find()`是互相关联的
{{< /admonition >}}


### quick-find

一种方法是保证当且仅当`id[p] == id[q]`时，`q`和`p`是连通的。换句话说，同一个连通分量中的所有对象在`id[]`中的值必须全部相同。

因此，对于`union()`操作，要将两个分量合二为一，我们必须修改两个集合中所有对象的`id[]`值，使之相同。

对于`find()`操作，则只需返回该对象所对应的数组值`id[p]`。

```python
class QuickFind(UF):
    
    def union(self, p, q):
        pid = self.find(p)	
        qid = self.find(q)

        if pid == qid:
            return 
        for i in range(0, self.lens):
            if self.id[i] == qid:	
                self.id[i] = pid 

    def find(self, p):
        return self.id[p]
    
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```
{{< admonition type=warning title="quick-find实现的陷阱" open=false >}}
-   不要直接赋值`pid = id[p]`，这违反了**抽象屏障**
-   不要直接判断`if self.id[i] == self.id[q]`，参见练习1.5.8
{{< /admonition >}}

#### quick-find的时间复杂度分析

在`quick-find`算法中， `find()`方法只需要访问数组一次。

对于`union()`操作来说，每一次调用的**固定代价**是访问`N+2`次数组：

-   调用2次`find()`，即访问数组两次。
-   检查数组的`N`个元素`if self.id[i] == qid`，即访问数组`N`次。

**浮动的代价**是需要改变的元素的数量`self.id[i] = pid`，即访问数组`1～N-1`次。

将这两部分相加即可得到**quick-find算法的`union()`操作访问数组的次数在`(N+3)～(2N+1)`之间。**。

假设我们使用`quick-find`算法来解决动态连通性问题并且最后只得到了**一个**连通分量，那么这至少需要调用`(N-1)`次`union()`——**即所有元素都连接在一起且完全无冗余连接**，那么需要**至少`(N+3)(N-1)≈N<sup>2</sup>`次数<组访问**，因此`quick-find`算法的时间复杂度度是平方级别的。

对于动态连通性这种需要处理大量数据的问题来说，平方级算法是不可接受的。例如一个社交网络，包含了几亿的用户，判断某两个用户之间是否有连接，使用这样的算法完全不可行。

### quick-union  

现在的问题是`union()`操作的代价太高，这是由于每连接两个连通分量就需要**修改**其中一个连通分量中<mark>**所有对象的id[]值**</mark>。

`quick-find`中每个`id[]`值直接表示了其所属的连通分量，但现在，**我们赋予`id[]`值别的意义**——即每个对象的`id[]`值都是同一个分量中的另一个对象的名称。其实这就是树，画个图就很好理解:
{{< image src="/images/image-20241110214709057.png" caption="quick-union生成的树" >}}

当且仅当两个对象沿其路径指向同一个根节点时他们才属于同一个连通分量。

对于`union()`操作，我们需要通过`find()`查找两个对象的根节点，归并时只需要使其中一个根节点指向另一个根节点即可。经由归并操作，我们会得到一颗**逻辑上**的树，即使数据结构是一维的数组。

**该算法的难点在于理解树的结构以及表示**，实现代码如下：

```python
class QuickUnion(UF):
    # id数组现在表示每个节点是一颗树，而不是quickfind中的值，其实quickfind中的id也可以视作全部是深度为1的树
    def union(self, p, q):
        proot = self.find(p)
        qroot = self.find(q)

        if proot == qroot:
            return 
        self.id[qroot] = proot

    def find(self, p):
        while p != self.id[p]:
            p = self.id[p]
        return p

    def connected(self, p, q):
        return self.find(p) == self.find(q)
```

#### quick-union的时间复杂度分析

从代码中可以看出，`union()`方法依赖于`find()`，所以整个算法的时间复杂度**取决于`find()`**。

而`find()`方法访问数组的次数为`1 + 给定对象节点的深度的两倍`。`1`是每次对`while条件`的固定判断；`深度的两倍`是因为节点每次沿路径到达下一个节点(即深度-1)时需要访问`两次`数组，**一次while判断，一次修改指向的赋值**。

`quick-union()`算法的最坏情况是生成一颗没有分支的**长链状**的树，如0链接到1，1链接到2，2链接到3......

对于整数对`0～i`，`union()`访问数组的次数为`2i+1`(对象`0`的深度为`i-1`, 对象`i`的深度为`0`)。

因此，通过`quick-union`算法将所有对象链接成最坏情况下的长链树，访问数组的总次数为`3+5+7+......+(2N-1)≈N^2^` 。

`quick-union`算法解决了`quick-find`算法中**最主要的问题**——`union()操作`**总是线性级别的**，因此提高了速度。但我们不能保证在所有情况下它都能比`quick-find`算法快。他们在最坏的情况下的时间复杂度都是`N^2^ `级别的。

要继续优化算法，我们只需要在`quick-union`算法的基础上，尽量减小树的深度。

### quick-union weight

在`quick-union()`中，我们归并的操作是**无向**的；然而，我们可以使归并操作是<mark>**有向**</mark>的，即**总是将深度小的树归并到深度大的树**，这样会大大降低树的深度(**宽度换深度**)。

对于这种有选择的归并，我们有两种方法：按秩和并 or 按树的大小合并。我们新增一个实例变量`size[]`来记录树的大小。实现代码如下：

```python
class weight_QuickUnion(QuickUnion):

    def __init__(self, N):
      self.lens = N
      self.id = []
      self.size = []
      self.operation_count = 0 
      for i in range(0, N):
        self.id.append(i)
        # 每个树的初始大小为1，即只有根节点
        self.size.append(1)       

    # 重写union函数通过size数组实现加权
    def union(self, p, q):
        proot = self.find(p)
        qroot = self.find(q)

        if proot == qroot:
            return 
        
        if self.size[proot] > self.size[qroot]:
            self.id[qroot] = proot
            self.size[proot] += self.size[qroot]
            self.operation_count += 0 
        else:
            self.id[proot] = qroot
            self.size[qroot] += self.size[proot]
            self.operation_count += 2 

    def find(self, p):
        while p != self.id[p]:
            p = self.id[p]
        return p
```

#### quick-union weighted的时间复杂度分析

 `quick-union weight`算法的**最坏情况**是：将要归并的树的大小总是相等的(且总是2的幂)。这些树都含有`2^n^个`节点，因此高度都正好是`n`。当我们归并这两个树时，新树含有`2^n+1^`个节点，高度为`n+1`(**这就是算法的效率所在，归并相当多的节点，树的高度也只是增加了1**)。

{{< admonition type=important title="命题H" open=true >}}  
对于`N`个对象，加权`quick-union`算法构造的树中的任意节点的深度最多为`lgN`。
  
证明：深度最大的情况就是`quick-union weight`算法的最坏情况，即将要归并的树的大小总是相等的(且总是2的幂)。用归纳法即可证明。同理可证**大小为`k`的树的高度最多为`lgk`**(因为合并`2^n^`个节点，高度只增加`1`，这是对数增长)  
{{< /admonition >}}

{{< admonition type=important title="推论" open=true >}}
对于加权quick-union算法和`N`个触点，在最坏情况下`find()、connected()和union()`的成本的增长数量级为`logN`。
{{< /admonition >}}


由命题H及其推论可以得出：**加权 quick-union 算法处理N个触点和M条链接时最多访问数组cMlgN次**，其中`C`是常数。

-   `find()`每一步通常涉及`2`次数组访问（一次读取节点的父节点，另一次更新当前节点指向新的节点）。因此，`find()` 的数组访问次数最多是 2⋅log⁡N。
-   那么每个`union()` 操作的数组访问次数最多为`4log⁡N`

### 路径压缩

理想情况下，我们希望每个节点都直接链接到它的根节点上，但我们又不想像`quick-find`算法那样通过**大量修改**每一个节点的指向，来做到这一点。

要实现路径压缩，只需要在`find()`中添加一个循环，保存路径上的每个节点，并在这个新的循环中让他们指向根节点。

```python
def find(self, p):
        path = []
        while p != self.id[p]:
            path.append(p)          
            p = self.id[p]
            self.operation_count += 2
        
        for i in path:
            self.id[i] = p
            self.operation_count += 1
        
        return p
```

我们所得到的结果是几乎完全<mark>**扁平化**</mark>的树，它和`quick-find`算法理想情况下所得到的树非常相似。


{{< admonition type=warning title="推论" open=true >}}
加权quick-union算法的时间复杂度是`cMlgN`.  
路径压缩的加权quick-union算法的时间复杂度是`O(M* alpha(N))`，它的增长数量级近似为`O(1)`(线性增长)，因为`alpha()`函数在真实世界最多为4。
{{< /admonition >}}




---

## 总结

-   研究算法及改进的基本步骤
-   用更高层次的抽象表示数据结构或算法来设计更高级的改进版本
    -   将id[]数组从一维“升维”成二维的树，再以宽度换深度。
-   <mark>**抽象过程**</mark>：迷宫——对象——求解连通分量——算法——树

---

## 课后试题

1.   路径压缩+按树的大小合并的quick-union算法得到的树的深度是<mark>**趋向最小深度**</mark>而不是绝对最小深度：

考虑以下 8 个节点 {0,1,2,3,4,5,6,7}\{0, 1, 2, 3, 4, 5, 6, 7\}{0,1,2,3,4,5,6,7} 以及如下操作顺序：

     1.  union(0,1)
     2.  union(2,3)
     3.  union(4,5)
     4.  union(6,7)
     5.  union(0,2)
     6.  union(4,6)
     7.  union(0,4)

算法的最小深度：

        0
       /|\
      1 2 4
        |  |\
        3  5 6
             |
             7

绝对最小深度：

         0
        /|\
       1 2 4
       | |  |\
       7 3  5 6
            

这是因为算法会按照给定的链接顺序执行`union()`操作，它并没有那么"**智能**"足以预想到最终的情况。

当然可以在链接全部执行完毕后，继续新增一些条件来优化使深度绝对最小，但是没有必要。

2.   一个重要的点是通过quick-union weitgh算法生成的树的形状是**固定**的，不会有一些**奇形怪状**的树。

---

## Project:蒙特卡罗渗漏
官方项目地址：[Programming Assignment 1: Percolation](https://coursera.cs.princeton.edu/algs4/assignments/percolation/specification.php)

这个项目不难理解，项目概述见：[并查集：渗透问题 | Yuan Tian's Blog](https://xzwj.github.io/2016/12/27/Union-Find-Percolation/)

我主要记录编程问题中遇到的难点与思考。

JAVA版实现参考<sup><a href="#ref1">1</a></sup>，我实现的python版见。<sup><a href="#ref2">2</a></sup>

### Percolation类实现

1.   怎样将二维的网格<mark>**映射**</mark>到一维数组？

     行数*N + 列数 == 一维数组中的对应下标。

2.   **open()的逻辑**

     -   首先，每个格子都要判断上下左右四个方向，若这四个临近方向`isOpen()`，那就使用union将他们连接起来。
     -   特殊地，最外围的一圈格子是没有四个方向的，例如第一排不考虑上方向的连接，第一列不考虑左方向的连接......因为这些地方都没有格子，如果还保持四个方向进行判断会导致数组越界。
     -   在这一步中进行虚拟节点的连接而不是初始化的时候，因为这也是在open节点，时刻注意函数的模块化思想。
     -   优化：我的实现里直接用了`row-1,col-1`这样的形式来表示上下左右四个方向，这其实是不好的。 首先修改和维护起来都很麻烦，比如要新增斜向的连接、行列数写错了要改很多东西。其次，这代码也非常非常的丑......但是我懒得改了，嘻嘻(●'◡'●)

3.   row与col的定义  
因为这个项目输入的是1～N行，但**众所周知数组是从0开始的**，这首先就导致一个很麻烦的问题问题，每涉及到一个行列操作都要对输入的`row-1,col-1`，几乎每个函数都要使用到row和col。  
其次，这在查看每个函数的时候，很容易让人**迷惑**，~~有时候一眼看不懂这个row和col到底代表的是那个格子本身还是映射到网格 or 数组里的下标~~。这个暂时没想到好的解决方法，慢慢习惯 or 多看看大佬的解决方法。

     -   我想到的最简单的就是定义的时候给`grid`数组多生成一行和一列，但是这也会带来额外的维护(比如需要手动考察一遍数组实际上越界了，但由于多了一行和一列python并不会报错)，所以放弃了，而且这也挺不符合面向对象的。

4.   `isFull()`判断的是某个站点是否与top连通
    我一开始以为是这个站点临近的四个方向都`isOpen`后，将该站点标记为`isFull`呵呵......

5.   虚拟节点的应用令人大开眼界

6.  回流问题(在可视化实现后才意识到来解决的)  
    回流指的是最下面的站点由于和`bottom`这个虚拟节点是连通的，在系统连通后，所有底部以开放的站点都是`isFull`状态，这是明显不对的。  
    解决方法是新增一个`uftop实例`只连接到`top`虚拟节点，而底部不连接到`bottom`节点，使用`uftop`来判断`isFull`。然后`open()`中也要对应修改，别的地方就不用修改了。相当于同时维护了两个并查集，其实这个成本还挺高的，不知道有没有更好的解决方法(懒得看了呵呵萌混过关=￣ω￣=......)

### 数据统计

这一部分没什么要注意的，理解对应的数学概念调用python的库就好，我使用的是numpy。不过有了这一步你就可以去反推、验证你的Percolation类实现的怎么样。我记得我一开始数据很差，因为这个是非常明确的收敛解<mark>**0.592**</mark>......我一直收敛到0.63左右，所以这个问题不容小觑。

忘了是改了些啥了，应该都是很小的问题。只要用这个输入跑出以下的结果就没问题：

### 可视化

可视化的时候有很多**奇怪**的小问题，比如不知道为什么一个站点莫名其妙的<mark>亮</mark>了，不知道为什么一个站点`isFull`，但就是~~不亮~~......这些其实都和`Percolation类`的实现有关，可能是`open()`函数的if判断逻辑有问题，可能是一些地方row,col没写对......这也体现了模块化的思想的重要性，因为发生这些问题的时候我完全不知道为什么也**不好调试**，只能回头去一遍遍地看`Percolation类`的实现。

但只要`Percolation类`实现的没问题的话，这些可视化代码都不用自己写，直接问chatGPT然后做出对应的修改就OK了。

### 项目总结

其实除了给最基本的算法写代码，<mark>**还有很多事情要做**</mark>。尤其我使用python没有官网的API使用，不过我本来也是来学算法的，所以自己实现一遍也是应该的。

从UnionFind的实现开始，要生成测试文件，要画并查集的连接图，要测试时间复杂度并且画图(一开始我粗心大意测试的是代码运行时间而不是数组访问次数，结果调了半天......也是巩固知识了)，最后还要组织文件——导包路径真给我整恶心了。

不过这些都是很基本的功能，让chatGPT帮忙写就好了，自己就**大概看一下**random类，matplotlib类的使用就好了，<mark>**千万不要自力求什么都看懂**</mark>。需求驱动一切，上面这些“**额外**”的东西都是我自己写着写着发现有了这样的需求，才去做的，这就很自然，也是我觉得学东西应该遵循的模式。而不是一开始就想把什么都给你，然后你就去刷题就完事了(~~呵呵应该懂我在暗示什么~~)......

一方面完美主义很害人，一方面这也很无聊，最后这还很不切实际，**一个良好的系统是自底向上生长出来的，而不是自顶向下的创造**。

---

## 应用


---

## 试题

剑指offer Ⅱ 116，118



---


## 结语

写这些东西的时候我又回头去玩了拼图游戏，我现在仍旧不知道它的算法，但我可以从互联网上轻而易举的获取答案。可我不想那样做，我想自己去尝试解开这个问题。

大一的时候用C写了一个搜索迷宫线路的程序，用的就是暴力穷举。那也是我写的第一个"**大型**"程序(对当时来说)，应该有200多行。上下左右四个方向，碰壁了就回溯......很笨，但是很自然的想法。**那时不知道什么算法，也不懂复杂度，反正最后跑起来了很开心**。

重头开始系统学习算法。了解了很多书和课程，最终还是掏出了当年买的第一本算法书——红宝石。第一个算法就是并查集，当时**囫囵吞枣**的就看过去了也没想着实现，觉得和自己要学的没啥关系。因为它篇幅很长，而我当时总是想着抽象、简洁、高级的“算法”，直接就排序-查找-树-图这种经典的顺序。直到今天看了网课才发现它其实很有趣很优雅，也可能是自己的<mark>**心态**</mark>变了吧。不再有刷题、竞赛、工作...这样“**功利**”的想法。所以按照自己的想法记录下了这第一篇学习笔记(参考了cs61a的方式)，但可能有点**冗长**了，不过是写给自己看的，自己舒服就好～

这一次我想看见那背后的世界，用我自己的方式(也许很笨)，为的是对智识的渴望和一丢丢找工作的硬性需求。

完全理解一切，

Hello World!

---

## 参考

[1] 蒙特卡洛渗漏JAVA版实现  
    没有解决回流问题，但是代码逻辑更简单易懂。
	<a name = "ref1" 	href="https://github.com/xzwj/PrincetonAlgs4/blob/master/src/Percolation.java">https://github.com/xzwj/PrincetonAlgs4/blob/master/src/Percolation.java</a>  
    解决回流问题  
    https://github.com/xiaolin5167/algo-week1-percolation/blob/master/src/Percolation.java

[2] 我的python实现：<a name="ref2"  href="https://github.com/renYeluv?tab=repositories">https://github.com/renYeluv?tab=repositories </a>


---

文章更新日志

  
