# Union Find


# 算法笔记(1):并查集

我其实挺喜欢玩解密类的游戏，最早接触的这类游戏应该是诺基亚上的蒙娜丽莎拼图，那个时候总是瞎玩，有时三俩下就拼好，有时10分钟也不见得能成功。

其实当时**隐隐约约能感觉到有一种规律**，比如我总是先把当前能对上号的图片放到正确的位置，再观察余下的要怎么拼；比如有时为了挪动一块拼图到正确的位置而不得不挪动许多块，而这经常是结尾要做的事，将最后一块拼图挪进去，需要以一种“奇怪”的方法，我称之为倒车入库，那时在这种情况下总是有一种奇妙的感觉。可惜自己也并非聪慧过人 or 好奇心爆棚，所以也不曾探索他的规律。而现在，这叫做==算法==。

除了拼图之外，大概就是走迷宫了。经常会在报纸或者杂志书上面有一些迷宫，我就用着铅笔“暴力”尝试(哈哈其实有眼睛的参与，没有穷举那么暴力)。

所以在学习并查集的时候，我很自然的就想到了迷宫的例子。迷宫可以看作这样一个问题：是否存在一条从起点到终点的路径？若是，则给出这条路径；若否，请给出理由。

⚠：实际上通过并查集我们并不知道这条连通路径具体是怎样的，我们要回答的首先是是否存在这样一条连通路径。

## 问题

对于一个给定的迷宫，判断该迷宫是否有出口。

![toolwa-maze](D:/Typora/IMAGE/toolwa-maze-1730970746406-2.png)

对于这样较小的迷宫，肉眼就能很快得出答案，但对于大型迷宫来讲，就不得不借助计算机的帮助。然而迷宫问题对计算机来说相当困难，因为他并不像人一样能"**看见**"。

![image-20241110215317084](D:/Typora/IMAGE/image-20241110215317084.png)

![image-20241110215358585](D:/Typora/IMAGE/image-20241110215358585.png)

## 建模

因此我们需要继续简化问题。**要时刻记住，算法和编程是两个"领域"，编程是将算法处理成计算机能理解的形式，而算法是给出解决问题的步骤，算法才是最基本的。**

我们需要表示迷宫的每个"格子"，我们将每个格子**抽象**为一个对象，并用1～n的数字作为唯一标识。并考虑一个更简单的例子：

![image-20241110214512051](D:/Typora/IMAGE/image-20241110214512051.png)

这个例子和迷宫的区别在于迷宫只有上下左右四个方向进行连接，而该例任意两个元素之间都可以连接。所以如果找到这个问题的算法，我们就能直接应用到迷宫上。这是第二层抽象。

现在，我们就将迷宫这个较**特殊**的问题**转化成**如下的**一般性**问题：

*问题：给出一组输入，判断任意两个元素之间是否相连。*

*输入：第一行为正整数n，表示有多少个元素。余下每行表示这两个元素相连。*

*输出：若相连，输出True;否则输出False*

此外，我们假设”相连“是一种等价关系，即具有如下性质：

-   自反性：p和p是相连的。

-   对称性：如果p和q是相连的，那么q和p也是相连的。

-   传递性：如果p和q是相连的且q和r是相连的，那么p和r也是相连的。

等价关系能够将对象分为多个等价类。对于该问题，当且仅当两个对象相连时它们才属于同一个等价类。至此我们将问题==**转化**==为求解连通分量。这是第三层抽象。至此，我们才正式开始算法的设计，前面都是具体的定义问题。

我们需要设计一种数据结构和算法，来==**保存**已知的所有等价类的**足够多的信息**==，并用它们来==**判断**==一对新对象是否是相连的(方法为判断它们是否属于同一个等价类)。这也叫动态连通性问题。

我们将等价类称为连通分量。

## 数据结构与API

对于求解连通分量问题，我们可以进一步细化为如下算法雏形：

1.   一开始每个对象都是一个连通分量，所以我们有N个分量，并且我们需要为这N个分量设立唯一标识符。
2.   当给出一组连接时，我们需要判断它们是否属于同一个分量。
     -   若是，则无需操作。
     -   若不是，则归并这两个分量。
3.   我们需要查找给定对象所处的分量的标识符。
     -   为什么需要这个函数？
     -   我们假设两个对象p,q，他们的分量标识符为m,n。因为2中的归并操作会将m, n归并为一个代表分量的唯一标识符，我们现在并不知道是如何修改的。也许是把m变成n、把n变成m、或者新增一个唯一标识符t,将m,n都修改为t等等情况.......但我们知道的是这会修改p,q中至少一个对象的标识符。
     -   查找的难易程度会取决于算法的设计，我们只是像往常一样，将这种独立的操作封装为一个函数。因为这就是函数设计的原则。
4.   通过上述两个函数，我们现在就可以查找两个对象是否属于同一分量，并返回结果。

因此我们给出如下API：

```python
class UF:
    def __init__(self, N):				 # 以整数标识(0～N-1)初始化N个对象
    def union(self， p, q):			   # 在p和q之间添加一条连接
    def find(self, p):				   # 查找给定对象所处的连通分量的标识符
    def connected(self, p, q):		   # 判断p和q之间是否存在连接
    def count(self):				   # 连通分量的数量
```

我们设计的==**数据结构**==如下：

-   使用数组的下标i表示对象。
-   数组的值id[i]来表示该对象的分量所对应的标识符。

对于init，我们使用每个对象i来初始化它的分量标识符，即id[i] = i (i属于0,N-1)

union,find是我们需要继续细化的算法

connected可以很方便地用find(p) == find(q)来判断。



因此我们定义出以下基类UF：

```python
class UF:
    
    def __init__(self, N):
      self.lens = N
      self.id = []
      for i in range(0, N):
        self.id.append(i)

    def union(self, p, q):
        return None
    
    def find(self, p): # 查找给定元素所处的集合的标识符
        return None

    def connected(self, p, q):
        return self.find(p) == self.find(q)
    
```

此外，为了分析算法的性能，我们将时间复杂度分析的成本定义为不同算法访问数组的总次数。

==Tips: (不是真正的运行时间，不然得出的时间复杂度图像不稳定)==

## 算法

**union()与find()是互相关联的。**

### quick-find

一种方法是保证当且仅当id[p] == id[q]时，q和p是连通的。换句话说，同一个连通分量中的所有对象在id[]中的值必须全部相同。

因此，对于union()操作，要将两个分量合二为一，我们必须修改两个集合中所有对象的id[]值，使之相同。

对于find()操作，则只需返回该对象所对应的数组值id[p]。

```python
class QuickFind(UF):
    
    def union(self, p, q):
        pid = self.find(p)	
        qid = self.find(q)

        if pid == qid:
            return 
        for i in range(0, self.lens):
            if self.id[i] == qid:	
                self.id[i] = pid 

    def find(self, p):
        return self.id[p]
    
    def connected(self, p, q):
        return self.find(p) == self.find(q)
```

需要注意的点：

-   不要直接赋值pid = id[p]，这违反了抽象屏障
-   不要直接判断if self.id[i] == self.id[q]，参见练习1.5.8

#### 时间复杂度分析

在quick-find算法中， find()方法只需要访问数组一次。

对于union()操作来说，每一次调用的固定代价是访问N+2次数组：

-   调用2次find()，即访问数组两次。
-   检查数组的N个元素(if self.id[i] == qid)，即访问数组N次。

浮动的代价是需要改变的元素的数量(self.id[i] = pid)，即访问数组1～N-1次。

将这两部分相加即可得到**quick-find算法的union()操作访问数组的次数在(N+3)～(2N+1)之间。****。

假设我们使用quick-find算法来解决动态连通性问题并且最后只得到了一个连通分量，那么这至少需要调用(N-1)次union()——即所有元素都连接在一起且完全无冗余连接，那么需要**至少(N+3)(N-1)≈N^2^ 次数组访问**，因此quick-find算法的时间复杂度度是平方级别的。

对于动态连通性这种需要处理大量数据的问题来说，平方级算法是不可接受的。例如一个社交网络，包含了几亿的用户，判断某两个用户之间是否有连接，使用这样的算法完全不可行。

### quick-union  

现在的问题是union()操作的代价太高，这是由于每连接两个连通分量就需要**修改**其中一个连通分量中**所有对象的id[]值**。

quick-find中每个id[]值直接表示了其所属的连通分量，但现在，**我们赋予id[]值别的意义**——即每个对象的id[]值都是同一个分量中的另一个对象的名称。其实这就是树，画个图就很好理解。

当且仅当两个对象沿其路径指向同一个根节点时他们才属于同一个连通分量。

对于union()操作，我们需要通过find()查找两个对象的根节点，归并时只需要使其中一个根节点指向另一个根节点即可。经由归并操作，我们会得到一颗**逻辑上**的树，即使数据结构是一维的数组。

![image-20241110214709057](D:/Typora/IMAGE/image-20241110214709057.png)

**该算法的难点在于理解树的结构以及表示(即这颗树是怎么生成的？)**，实现代码如下：

```python
class QuickUnion(UF):
    # id数组现在表示每个节点是一颗树，而不是quickfind中的值，其实quickfind中的id也可以视作全部是深度为1的树
    def union(self, p, q):
        proot = self.find(p)
        qroot = self.find(q)

        if proot == qroot:
            return 
        self.id[qroot] = proot

    def find(self, p):
        while p != self.id[p]:
            p = self.id[p]
        return p

    def connected(self, p, q):
        return self.find(p) == self.find(q)
```

#### 时间复杂度分析

从代码中可以看出，union()方法依赖于find()，所以整个算法的时间复杂度取决于find()。

而find()方法访问数组的次数为1 + 给定对象节点的深度的两倍。1是每次对while条件的固定判断；深度的两倍是因为节点每次沿路径到达下一个节点(即深度-1)时需要访问两次数组，一次while判断，一次修改指向的赋值。

quick-union()算法的最坏情况是生成一颗没有分支的长链状的树，如0链接到1，1链接到2，2链接到3......

对于整数对0～i，union()访问数组的次数为2i+1(对象0的深度为i-1, 对象i的深度为0)。

因此，通过quick-union算法将所有对象链接成最坏情况下的长链树，访问数组的总次数为3+5+7+......+(2N-1)≈N^2^ 。

quick-union算法解决了quick-find算法中**最主要的问题**——union()操作**总是线性级别的**，因此提高了速度。但我们不能保证在所有情况下它都能比quick-find算法快。他们在最坏的情况下的时间复杂度都是N^2^ 级别的。

要继续优化算法，我们只需要在quick-union算法的基础上，尽量减小树的深度。

### quick-union weight

在quick-union()中，我们归并的操作是无向的；然而，我们可以使归并操作是==**有向**==的，即总是将深度小的树归并到深度大的树，这样会大大降低树的深度(**宽度换深度**)。

对于这种有选择的归并，我们有两种方法：按秩和并 or 按树的大小合并。我们新增一个实例变量size[]来记录树的大小。实现代码如下：

```python
class weight_QuickUnion(QuickUnion):

    def __init__(self, N):
      self.lens = N
      self.id = []
      self.size = []
      self.operation_count = 0 
      for i in range(0, N):
        self.id.append(i)
        # 每个树的初始大小为1，即只有根节点
        self.size.append(1)       

    # 重写union函数通过size数组实现加权
    def union(self, p, q):
        proot = self.find(p)
        qroot = self.find(q)

        if proot == qroot:
            return 
        
        if self.size[proot] > self.size[qroot]:
            self.id[qroot] = proot
            self.size[proot] += self.size[qroot]
            self.operation_count += 0 
        else:
            self.id[proot] = qroot
            self.size[qroot] += self.size[proot]
            self.operation_count += 2 

    def find(self, p):
        while p != self.id[p]:
            p = self.id[p]
        return p
```

#### 时间复杂度分析

 quick-union weight算法的最坏情况是：将要归并的树的大小总是相等的(且总是2的幂)。这些树都含有2^n^个节点，因此高度都正好是n。当我们归并这两个树时，新树含有2^n+1^ 个节点，高度为n+1(**这就是算法的效率所在，归并相当多的节点，树的高度也只是增加了1**)。

命题H：对于N个对象，加权quick-union算法构造的树中的任意节点的深度最多为lgN。

证明：深度最大的情况就是 quick-union weight算法的最坏情况，即将要归并的树的大小总是相等的(且总是2的幂)。用归纳法即可证明。同理可证==**大小为k的树的高度最多为lgk**==(因为合并2^n^ 个节点，高度只增加1，这是对数增长)

推论：对于加权quick-union算法和N个触点，在最坏情况下find()、connected()和union()的成本的增长数量级为logN。

由命题H及其推论可以得出：**加权 quick-union 算法处理N个触点和M条链接时最多访问数组cMlgN次**，其中C是常数。

-   find()每一步通常涉及 2 次数组访问（一次读取节点的父节点，另一次更新当前节点指向新的节点）。因此，`find()` 的数组访问次数最多是 2⋅log⁡N。
-   那么每个`union()` 操作的数组访问次数最多为 4 log⁡N

### 路径压缩

理想情况下，我们希望每个节点都直接链接到它的根节点上，但我们又不想像quick-find算法那样通过**大量修改**每一个节点的指向，来做到这一点。

要实现路径压缩，只需要在find()中添加一个循环，保存路径上的每个节点，并在这个新的循环中让他们指向根节点。

```python
def find(self, p):
        path = []
        while p != self.id[p]:
            path.append(p)          
            p = self.id[p]
            self.operation_count += 2
        
        for i in path:
            self.id[i] = p
            self.operation_count += 1
        
        return p
```

我们所得到的结果是几乎完全==**扁平化**==的树，它和quick-find算法理想情况下所得到的树非常相似。



⚠

加权quick-union算法的时间复杂度是cMlgN

路径压缩的加权quick-union算法的时间复杂度是O(M* alpha(N))，是它的增长数量级近似为O(1)(线性增长)，因为alpha()函数在真实世界最多为4。

## 总结

-   研究算法及改进的基本步骤
-   用更高层次的抽象表示数据结构或算法来设计更高级的改进版本
    -   将id[]数组从一维“升维”成二维的树，再以宽度换深度。

## 课后试题

1.   路径压缩+按树的大小合并的quick-union算法得到的树的深度是==**趋向最小深度**==而不是绝对最小深度：

考虑以下 8 个节点 {0,1,2,3,4,5,6,7}\{0, 1, 2, 3, 4, 5, 6, 7\}{0,1,2,3,4,5,6,7} 以及如下操作顺序：

1.  union(0,1)
2.  union(2,3)
3.  union(4,5)
4.  union(6,7)
5.  union(0,2)
6.  union(4,6)
7.  union(0,4)

算法的最小深度：

        0
       /|\
      1 2 4
        |  |\
        3  5 6
              |
              7

绝对最小深度：

        0
       /|\
      1 2 4
      | |  |\
      7 3  5 6
            

这是因为算法会按照给定的链接顺序执行union()操作，它并没有那么"智能"足以预想到最终的情况。

当然可以在链接全部执行完毕后，继续新增一些条件来优化使深度绝对最小，但是没有必要。

2.   一个重要的点是通过quick-union weitgh算法生成的树的形状是固定的，不会有一些奇形怪状的树。

## Project:蒙特卡罗渗漏



## 应用



## 试题

剑指offer Ⅱ 116，118





## 结语

写这些东西的时候我又回头去玩了拼图游戏，我现在仍旧不知道它的算法，但我可以从互联网上轻而易举的获取答案。可我不想那样做，我想自己去尝试解开这个问题。

大一的时候用C写了一个搜索迷宫线路的程序，用的就是暴力穷举。那也是我写的第一个"大型"(对当时来说)程序，应该有200多行。上下左右四个方向，碰壁了就回溯......很笨，但是很自然的想法。那时不知道什么算法，也不懂复杂度，反正最后跑起来了很开心。

重头开始系统学习算法。了解了很多书和课程，最终还是掏出了当年买的第一本算法书——红宝石。第一个算法就是并查集，当时囫囵吞枣的就看过去了也没想着实现，觉得和自己要学的没啥关系。因为它篇幅很长，而我当时总是想着抽象、简洁、高级的“算法”，直接就排序-查找-树-图这种经典的顺序。直到今天看了网课才发现它其实很有趣很优雅，也可能是自己的心态变了吧。不再有刷题、竞赛、工作...这样“功利”的想法。所以按照自己的想法记录下了这第一篇学习笔记(参考了cs61a的方式)，但可能有点冗长了，不过是写给自己看的，自己舒服就好～

这一次我想看见那背后的世界，用我自己的方式(也许很笨)，为的是对智识的渴望和一丢丢找工作的硬性需求。

完全理解一切，

Hello World!



---

文章更新日志

  
